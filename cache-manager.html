<script>
/* ====== [SPX] DAILY CHECKLIST - UNIFIED CACHE MANAGER ====== */
/* File: cache-manager.html - Centralized caching system */

(function() {
  'use strict';

  /**
   * Unified Cache Manager
   * Provides consistent caching API for both client-side and server-side
   * Automatically handles TTL, size limits, and storage quotas
   */
  window.UnifiedCache = {
    /* ====== CONFIGURATION ====== */
    config: {
      enabled: true,
      maxSize: 50, // Maximum number of cached items
      defaultTTL: 5 * 60 * 1000, // 5 minutes default

      // Predefined TTLs for different data types
      ttl: {
        USER_PERMISSIONS: 5 * 60 * 1000,   // 5 minutes (rarely change)
        TASK_TEMPLATE: 30 * 60 * 1000,     // 30 minutes (rarely change)
        TASKS: 10 * 60 * 1000,             // 10 minutes (may change frequently)
        REPORTS: 10 * 60 * 1000,           // 10 minutes (computational expensive)
        ALL_USERS: 5 * 60 * 1000,          // 5 minutes
        NOTES: 3 * 60 * 1000,              // 3 minutes
        QA_DATA: 5 * 60 * 1000,            // 5 minutes
        CHAT_MESSAGES: 1 * 60 * 1000,      // 1 minute (real-time)
        TASK_INDEX: 5 * 60 * 1000          // 5 minutes
      }
    },

    /* ====== PRIVATE STATE ====== */
    _cache: {},
    _stats: {
      hits: 0,
      misses: 0,
      sets: 0,
      evictions: 0
    },

    /* ====== INITIALIZATION ====== */

    /**
     * Initialize cache from localStorage
     */
    init: function() {
      try {
        var stored = localStorage.getItem('spx_unified_cache');
        if (stored) {
          this._cache = JSON.parse(stored);
          this._cleanExpired();
        }

        if (window.logger) {
          window.logger.log('[UnifiedCache] Initialized with ' + Object.keys(this._cache).length + ' entries');
        }
      } catch (e) {
        console.warn('[UnifiedCache] Init error:', e);
        this._cache = {};
      }
    },

    /* ====== CORE CACHE OPERATIONS ====== */

    /**
     * Get value from cache
     * @param {string} key - Cache key
     * @return {*} Cached value or null if not found/expired
     */
    get: function(key) {
      if (!this.config.enabled || !key) return null;

      var item = this._cache[key];

      if (!item) {
        this._stats.misses++;
        return null;
      }

      // Check if expired
      if (Date.now() > item.expires) {
        delete this._cache[key];
        this._save();
        this._stats.misses++;
        return null;
      }

      this._stats.hits++;
      return item.data;
    },

    /**
     * Set value in cache
     * @param {string} key - Cache key
     * @param {*} value - Value to cache
     * @param {number} ttl - Time to live in milliseconds (optional)
     * @return {boolean} Success status
     */
    set: function(key, value, ttl) {
      if (!this.config.enabled || !key) return false;

      try {
        var expires = Date.now() + (ttl || this.config.defaultTTL);

        this._cache[key] = {
          data: value,
          expires: expires,
          timestamp: Date.now(),
          size: this._estimateSize(value)
        };

        this._stats.sets++;

        // Enforce max size
        this._enforceMaxSize();

        // Save to localStorage
        this._save();

        return true;
      } catch (e) {
        console.warn('[UnifiedCache] Set error:', e);

        // Handle quota exceeded
        if (e.name === 'QuotaExceededError') {
          this._handleQuotaExceeded();
        }

        return false;
      }
    },

    /**
     * Remove value from cache
     * @param {string} key - Cache key
     */
    remove: function(key) {
      if (this._cache[key]) {
        delete this._cache[key];
        this._save();
      }
    },

    /**
     * Clear cache (all or by pattern)
     * @param {string} pattern - Optional pattern to match keys (e.g., 'tasks_')
     */
    clear: function(pattern) {
      if (pattern) {
        // Clear matching keys
        var cleared = 0;
        Object.keys(this._cache).forEach(function(key) {
          if (key.indexOf(pattern) !== -1) {
            delete this._cache[key];
            cleared++;
          }
        }.bind(this));

        if (window.logger && cleared > 0) {
          window.logger.log('[UnifiedCache] Cleared ' + cleared + ' entries matching "' + pattern + '"');
        }
      } else {
        // Clear all
        this._cache = {};
        if (window.logger) {
          window.logger.log('[UnifiedCache] Cleared all entries');
        }
      }

      this._save();
    },

    /**
     * Check if key exists and is valid
     * @param {string} key - Cache key
     * @return {boolean}
     */
    has: function(key) {
      var item = this._cache[key];
      if (!item) return false;

      // Check expiration
      if (Date.now() > item.expires) {
        delete this._cache[key];
        this._save();
        return false;
      }

      return true;
    },

    /* ====== SPECIALIZED CACHE OPERATIONS ====== */

    /**
     * Get or compute (cache-aside pattern)
     * If key exists in cache, return it. Otherwise, compute value and cache it.
     * @param {string} key - Cache key
     * @param {Function} computeFn - Function to compute value if not cached
     * @param {number} ttl - Time to live in milliseconds (optional)
     * @return {Promise} Promise resolving to cached or computed value
     */
    getOrCompute: function(key, computeFn, ttl) {
      var cached = this.get(key);

      if (cached !== null) {
        return Promise.resolve(cached);
      }

      return Promise.resolve(computeFn()).then(function(value) {
        this.set(key, value, ttl);
        return value;
      }.bind(this));
    },

    /**
     * Batch get multiple keys
     * @param {Array<string>} keys - Array of cache keys
     * @return {Object} Object with keys and their cached values (or null if not found)
     */
    batchGet: function(keys) {
      var result = {};
      keys.forEach(function(key) {
        result[key] = this.get(key);
      }.bind(this));
      return result;
    },

    /**
     * Batch set multiple key-value pairs
     * @param {Object} items - Object with key-value pairs
     * @param {number} ttl - Time to live in milliseconds (optional)
     */
    batchSet: function(items, ttl) {
      Object.keys(items).forEach(function(key) {
        this.set(key, items[key], ttl);
      }.bind(this));
    },

    /* ====== TASK-SPECIFIC CACHE METHODS ====== */

    /**
     * Get tasks from cache
     * @param {string} hub - Hub ID
     * @param {string} date - Date string (YYYY-MM-DD)
     * @return {Array|null} Tasks array or null if not cached
     */
    getTasks: function(hub, date) {
      var key = 'tasks_' + hub + '_' + date;
      return this.get(key);
    },

    /**
     * Set tasks in cache
     * @param {string} hub - Hub ID
     * @param {string} date - Date string (YYYY-MM-DD)
     * @param {Array} tasks - Tasks array
     */
    setTasks: function(hub, date, tasks) {
      var key = 'tasks_' + hub + '_' + date;
      return this.set(key, tasks, this.config.ttl.TASKS);
    },

    /**
     * Clear tasks cache
     * @param {string} hub - Hub ID (optional, clears all tasks if not provided)
     * @param {string} date - Date string (optional)
     */
    clearTasks: function(hub, date) {
      if (hub && date) {
        var key = 'tasks_' + hub + '_' + date;
        this.remove(key);
      } else if (hub) {
        this.clear('tasks_' + hub);
      } else {
        this.clear('tasks_');
      }
    },

    /* ====== CACHE MAINTENANCE ====== */

    /**
     * Clean expired entries
     * @private
     */
    _cleanExpired: function() {
      var now = Date.now();
      var cleaned = 0;

      Object.keys(this._cache).forEach(function(key) {
        var item = this._cache[key];
        if (now > item.expires) {
          delete this._cache[key];
          cleaned++;
        }
      }.bind(this));

      if (cleaned > 0 && window.logger) {
        window.logger.log('[UnifiedCache] Cleaned ' + cleaned + ' expired entries');
      }
    },

    /**
     * Enforce maximum cache size (LRU eviction)
     * @private
     */
    _enforceMaxSize: function() {
      var keys = Object.keys(this._cache);

      if (keys.length <= this.config.maxSize) return;

      // Sort by timestamp (oldest first)
      keys.sort(function(a, b) {
        return this._cache[a].timestamp - this._cache[b].timestamp;
      }.bind(this));

      // Remove oldest entries
      var toRemove = keys.length - this.config.maxSize;
      for (var i = 0; i < toRemove; i++) {
        delete this._cache[keys[i]];
        this._stats.evictions++;
      }

      if (window.logger) {
        window.logger.log('[UnifiedCache] Evicted ' + toRemove + ' old entries (LRU)');
      }
    },

    /**
     * Handle quota exceeded error
     * @private
     */
    _handleQuotaExceeded: function() {
      if (window.logger) {
        window.logger.warn('[UnifiedCache] Storage quota exceeded, clearing cache');
      }

      // Clear half of the cache (oldest entries)
      var keys = Object.keys(this._cache);
      keys.sort(function(a, b) {
        return this._cache[a].timestamp - this._cache[b].timestamp;
      }.bind(this));

      var toRemove = Math.ceil(keys.length / 2);
      for (var i = 0; i < toRemove; i++) {
        delete this._cache[keys[i]];
      }

      this._save();
    },

    /**
     * Estimate size of value (rough approximation)
     * @private
     * @param {*} value - Value to estimate
     * @return {number} Estimated size in bytes
     */
    _estimateSize: function(value) {
      try {
        return JSON.stringify(value).length;
      } catch (e) {
        return 0;
      }
    },

    /**
     * Save cache to localStorage
     * @private
     */
    _save: function() {
      try {
        localStorage.setItem('spx_unified_cache', JSON.stringify(this._cache));
      } catch (e) {
        console.warn('[UnifiedCache] Save error:', e);

        if (e.name === 'QuotaExceededError') {
          this._handleQuotaExceeded();
        }
      }
    },

    /* ====== CACHE STATISTICS & MONITORING ====== */

    /**
     * Get cache statistics
     * @return {Object} Cache stats
     */
    getStats: function() {
      var now = Date.now();
      var totalSize = 0;
      var validCount = 0;
      var expiredCount = 0;

      Object.keys(this._cache).forEach(function(key) {
        var item = this._cache[key];
        totalSize += item.size || 0;

        if (now > item.expires) {
          expiredCount++;
        } else {
          validCount++;
        }
      }.bind(this));

      return {
        total: Object.keys(this._cache).length,
        valid: validCount,
        expired: expiredCount,
        totalSize: totalSize,
        maxSize: this.config.maxSize,
        hits: this._stats.hits,
        misses: this._stats.misses,
        sets: this._stats.sets,
        evictions: this._stats.evictions,
        hitRate: this._stats.hits + this._stats.misses > 0
          ? (this._stats.hits / (this._stats.hits + this._stats.misses) * 100).toFixed(2) + '%'
          : '0%'
      };
    },

    /**
     * Reset statistics
     */
    resetStats: function() {
      this._stats = {
        hits: 0,
        misses: 0,
        sets: 0,
        evictions: 0
      };
    },

    /**
     * Log cache statistics (for debugging)
     */
    logStats: function() {
      var stats = this.getStats();
      console.log('[UnifiedCache] Statistics:', stats);
    }
  };

  // Auto-initialize on load
  window.UnifiedCache.init();

  // Periodic cleanup (every 5 minutes)
  setInterval(function() {
    window.UnifiedCache._cleanExpired();
  }, 5 * 60 * 1000);

  /* ====== BACKWARD COMPATIBILITY LAYER ====== */

  /**
   * CacheManager compatibility (for old code using CacheManager)
   * Maps old CacheManager API to UnifiedCache
   */
  window.CacheManager = {
    config: window.UnifiedCache.config,
    cache: window.UnifiedCache._cache,

    init: function() {
      return window.UnifiedCache.init();
    },

    get: function(action, data) {
      var key = action + '_' + JSON.stringify(data || {});
      return window.UnifiedCache.get(key);
    },

    set: function(action, data, value, ttl) {
      var key = action + '_' + JSON.stringify(data || {});
      return window.UnifiedCache.set(key, value, ttl);
    },

    clear: function(pattern) {
      return window.UnifiedCache.clear(pattern);
    },

    cleanExpired: function() {
      return window.UnifiedCache._cleanExpired();
    },

    enforceMaxSize: function() {
      return window.UnifiedCache._enforceMaxSize();
    },

    save: function() {
      return window.UnifiedCache._save();
    },

    getStats: function() {
      return window.UnifiedCache.getStats();
    }
  };

  /**
   * Task cache compatibility (for old code using task cache functions)
   * These functions map to UnifiedCache.getTasks/setTasks
   */
  window.getCachedTasks = function(storageKey) {
    // Extract hub and date from storageKey (format: tasks_HUB_DATE)
    var parts = storageKey.split('_');
    if (parts.length >= 3) {
      var hub = parts[1];
      var date = parts[2];
      return window.UnifiedCache.getTasks(hub, date);
    }
    return null;
  };

  window.saveTasksToCache = function(storageKey, tasks) {
    // Extract hub and date from storageKey
    var parts = storageKey.split('_');
    if (parts.length >= 3) {
      var hub = parts[1];
      var date = parts[2];
      return window.UnifiedCache.setTasks(hub, date, tasks);
    }
    return false;
  };

  window.clearTaskCache = function(storageKey) {
    // Extract hub and date from storageKey
    var parts = storageKey.split('_');
    if (parts.length >= 3) {
      var hub = parts[1];
      var date = parts[2];
      return window.UnifiedCache.clearTasks(hub, date);
    } else if (parts.length === 2) {
      // Only hub provided
      var hub = parts[1];
      return window.UnifiedCache.clearTasks(hub);
    } else {
      // Clear all tasks
      return window.UnifiedCache.clearTasks();
    }
  };

  window.getTaskCacheKey = function(key) {
    // Legacy function - now just returns the key as-is
    // UnifiedCache handles the key format internally
    return key;
  };

  if (window.logger) {
    window.logger.log('[UnifiedCache] Module loaded with backward compatibility');
  }
})();
</script>
